# C++📜

## 대입 연산자 오버로딩 🎯

- 대입 연산자의 오버로딩은 앞서 배운 복사 생성자와 성격이 매우 유사하다.
  - 공통점
    - 정의하지 않으면 디폴트 대입 연산자/복사 생성자가 삽입
    - 디폴트 대입 연산자/복사 생성자는 멤버대 멤버의 얇은 복사를 진행
    - 동적 할당 시에는 깊은 복사가 필요
  - 차이점
    - 대입 연산자는 피연산자에 해당하는 객체가 정의되어 있어야 하는 반면, 복사 생성자의 경우 생성과 초기화를 한번에 할 수 있다는 점을 봐선, 호출되는 시점이 다르다고 볼 수 있다.
- 대입 연산자의 문제점은 앞서 말한 복사 생성자의 문제점과 동일한데, 동적할당한 메모리가 있을 경우 이를 깊은 복사를 해줘야한다는 점이다.
  - 메모리 누수 , 중복 소멸 방지
  - 대입 연산자의 깊은 복사(대입) 예제
    ```cpp
    Person& operator=(const Person& ref)
    {
      delete []name;//값을 집어넣을 공간을 비우는 역할
      name = new char[strlen(ref.name)+1];
      strcpy(name,ref.name);
    }
    ```
- 대입연산자의 오버로딩이 되어있는 클래스가 상속 될 경우, 유도 클래스의 대입 연산자를 정의해서 사용할 경우 기초 클래스의 대입 연산자 호출문을 별도로 삽입하지 않으면, 호출되지 않는다.

## 효율이 좋은 이니셜라이저👍

- 이니셜라이즈는 멤버 변수를 초기화 할 경우에 효율이 좋은데 이 이유는 **복사생성자**와 **대입연산자의 오버로딩**을 비교함으로써 알 수 있다.

- 이니셜라이즈를 사용하는 경우 **선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성**되어지기 때문에

  ```cpp
  BBB(const AAA& ref) : mem(ref) {}//BBB클래스의 이니셜라이즈 사용 생성자 비유
  ```

  이와 같은 코드는 `AAA mem = ref; `로 비유할 수 있다.

- 이니셜라이즈를 사용하지 않고, 생성자의 몸체부분에서 초기화를 진행하면 **선언과 초기화를 별도로하는 바이너리 코드가 생성된다**
  ```cpp
  CCC(const AAA& ref) {mem = ref}//CCC클래스의 이니셜라이즈 미사용 생성자 비유
  ```
  따라서 이와 같은 코드는 아래와 같이 해석된다.
  ```cpp
  AAA mem();
  mem = ref;
  ```

## 인덱스 연산자 오버로딩 📦

- 인덱스 연산자의 오버로딩의 경우 `[]` 안에 들어가는 인덱스 값을 매개변수로 받아 처리할 수 있다.

  ```cpp
  int operator[] (int idx){}

  arrObject[2];//위와같이 오버로딩을 정의하여 따라서 이 문장이 오버로딩 됨에따라 arrObject.operator[](2);로 해석된다.
  ```

- C와 C++은 배열의 범위를 검사하는 **경계 검사**를 하지 않기 때문에 인덱스 연산자 오버로딩을 이용하여 프로그래머가 경계 검사 코드를 짜줄 수 있다.

- 객체 저장을 위한 인덱스 연산자 오버로딩의 경우 배열의 **객체의 주소 값을 저장하는 방식** 과 **객체 자체를 정장하는 방식**으로 나눠진다
  - 주소값을 저장하는 방식이 동적할당 및 해제를 해야함으로 복잡해보일 수 있지만, 얇은 복사로 인해 발생하는 문제점을 해결할 수 있어서 잘 쓰인다.
